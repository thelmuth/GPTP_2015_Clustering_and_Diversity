% Works not in the gp-bibliography.bib file.

@inproceedings{Helmuth:2015:GECCO,
	author = {Thomas Helmuth and Lee Spector},
	NOeditor = {Many People},
	title = {General program synthesis benchmark suite},
	booktitle = {GECCO '15: Proceedings of the 2015 Conference on
	Genetic and Evolutionary Computation},
	date = {July, 2015},
	year = {2015},
	eventtitle = {Conference on Genetic and Evolutionary Computation},
	eventdate = {July, 2015},
	location = {Madrid, Spain},
	month = {July},
}

@Manual{R,
	title = {R: A Language and Environment for Statistical Computing},
	author = {{R Core Team}},
	organization = {R Foundation for Statistical Computing},
	address = {Vienna, Austria},
	year = {2014},
	url = {http://www.R-project.org/},
}

@Manual{cluster,
 	title = {cluster: Cluster Analysis Basics and Extensions},
 	author = {Martin Maechler and Peter Rousseeuw and Anja Struyf and Mia Hubert and Kurt Hornik},
 	year = {2014},
 	note = {R package version 1.15.3},
}

@InProceedings{Spector:2012:GECCOcompANEW,
  author =	"Lee Spector",
  title =	"Assessment of Problem Modality by Differential
		 Performance of Lexicase Selection in Genetic
		 Programming: {A} Preliminary Report",
  booktitle =	"1st workshop on Understanding Problems (GECCO-UP)",
  year = 	"2012",
  NOeditor =	"Kent McClymont and Ed Keedwell",
  isbn13 =	"978-1-4503-1178-6",
  keywords =	"genetic algorithms, genetic programming, modal
		 problems, selection, lexicase selection, problem
		 metrics, modality",
  pages =	"401--408",
  month =	"7-11 " # jul,
  organisation = "SIGEVO",
  address =	"Philadelphia, Pennsylvania, USA",
  NOURL =  	"http://hampshire.edu/lspector/pubs/wk09p4-spector.pdf",
  doi =  	"doi:10.1145/2330784.2330846",
  publisher =	"ACM",
  publisher_address = "New York, NY, USA",
  size = 	"8 pages",
  abstract =	"Many potential target problems for genetic programming
		 are modal in the sense that qualitatively different
		 modes of response are required for inputs from
		 different regions of the problem's domain. This paper
		 presents a new approach to solving modal problems with
		 genetic programming, using a simple and novel parent
		 selection method called lexicase selection. It then
		 shows how the differential performance of genetic
		 programming with and without lexicase selection can be
		 used to provide a measure of problem modality, and it
		 argues that defining such a measure in this way is not
		 as methodologically problematic as it may initially
		 appear. The modality measure is illustrated through the
		 analysis of genetic programming runs on a simple modal
		 symbolic regression problem. This is a preliminary
		 report that is intended in part to stimulate discussion
		 on the significance of modal problems, methods for
		 solving them, and methods for measuring the modality of
		 problems. Although the core concepts in this paper are
		 presented in the context of genetic programming, they
		 are also relevant to applications of other forms of
		 evolutionary computation to modal problems.",
  notes =	"p403 'allowing the high-performing individual [on any
		 test case] to contribute to the following generation,
		 regardless of [its] performance on other cases.' p405
		 'with population size 10000 the overall cost of
		 producing offspring using lexicase selection can exceed
		 that of using ordinary tournaments by between one and
		 two orders of magnitude'. (why?) Section 5: integer
		 symbolic regresions with one, two or three 'modes'.
		 Clojure lexicase.clj
		 https://gist.github.com/lspector/2320883 Also known as
		 \cite{2330846} Distributed at GECCO-2012. ACM Order
		 Number 910122.",
  doi-url =	"http://dx.doi.org/10.1145/2330784.2330846",
}

@INPROCEEDINGS{Mckay00fitnesssharing,
    author = {R I McKay},
    title = {Fitness sharing in genetic programming},
    booktitle = {Proceedings of the Genetic and Evolutionary Computation Conference, pages 435â€“442, Las Vegas},
    year = {2000},
    pages = {10--12},
    publisher = {Morgan Kaufmann}
}

@Article{Helmuth:2014:ieeeTEC,
  author =	"Thomas Helmuth and Lee Spector and James Matheson",
  title =	"Solving Uncompromising Problems with Lexicase
		 Selection",
  year = {2014},
  journal =	"IEEE Transactions on Evolutionary Computation",
  keywords =	"genetic algorithms, genetic programming, parent
		 selection, lexicase selection, tournament selection,
		 PushGP",
  ISSN = 	"1089-778X",
  doi =  	"doi:10.1109/TEVC.2014.2362729",
  size = 	"14 pages",
  abstract =	"We describe a broad class of problems, called
		 uncompromising problems, characterised by the
		 requirement that solutions must perform optimally on
		 each of many test cases. Many of the problems that have
		 long motivated genetic programming research, including
		 the automation of many traditional programming tasks,
		 are uncompromising. We describe and analyse the
		 recently proposed lexicase parent selection algorition
		 and show that it can facilitate the solution of
		 uncompromising problems by genetic programming. Unlike
		 most traditional parent selection techniques, lexicase
		 selection does not base selection on a fitness value
		 that is aggregated over all test cases; rather, it
		 considers test cases one at a time in random order. We
		 present results comparing lexicase selection to more
		 traditional parent selection methods, including
		 standard tournament selection and implicit fitness
		 sharing, on four uncompromising problems: finding terms
		 in finite algebras, designing digital multipliers,
		 counting words in files, and performing symbolic
		 regression of the factorial function. We provide
		 evidence that lexicase selection maintains higher
		 levels of population diversity than other selection
		 methods, which may partially explain its utility as a
		 parent selection algorithm in the context of
		 uncompromising problems.",
  doi-url =	"http://dx.doi.org/10.1109/TEVC.2014.2362729",
}

@Article{spector:2002:GPEMnoURL,
  author =       "Lee Spector and Alan Robinson",
  title =        "Genetic Programming and Autoconstructive Evolution
                 with the Push Programming Language",
  journal =      "Genetic Programming and Evolvable Machines",
  year =         "2002",
  volume =       "3",
  number =       "1",
  pages =        "7--40",
  month =        mar,
  keywords =     "genetic algorithms, genetic programming, artificial
                 life, modularity, programming languages,
                 self-adaptation",
  ISSN =         "1389-2576",
  NOURL =          "http://hampshire.edu/lspector/pubs/push-gpem-final.pdf",
  doi =          "doi:10.1023/A:1014538503543",
  abstract =     "Push is a programming language designed for the
                 expression of evolving programs within an evolutionary
                 computation system. This article describes Push and
                 illustrates some of the opportunities that it presents
                 for evolutionary computation. Two evolutionary
                 computation systems, PushGP and Pushpop, are described
                 in detail. PushGP is a genetic programming system that
                 evolves Push programs to solve computational problems.
                 Pushpop, an ?autoconstructive evolution? system, also
                 evolves Push programs but does so while simultaneously
                 evolving its own evolutionary mechanisms.",
  notes =        "Article ID: 395988",
}

@InProceedings{1068292noURL,
  author =       "Lee Spector and Jon Klein and Maarten Keijzer",
  title =        "The Push3 execution stack and the evolution of
                 control",
  booktitle =    "{GECCO 2005}: Proceedings of the 2005 conference on
                 Genetic and evolutionary computation",
  year =         "2005",
  NOeditor =       "Hans-Georg Beyer and Una-May O'Reilly and Dirk V.
                 Arnold and Wolfgang Banzhaf and Christian Blum and Eric
                 W. Bonabeau and Erick Cantu-Paz and Dipankar Dasgupta
                 and Kalyanmoy Deb and James A. Foster and Edwin D. {de
                 Jong} and Hod Lipson and Xavier Llora and Spiros
                 Mancoridis and Martin Pelikan and Guenther R. Raidl and
                 Terence Soule and Andy M. Tyrrell and Jean-Paul Watson
                 and Eckart Zitzler",
  volume =       "2",
  ISBN =         "1-59593-010-8",
  pages =        "1689--1696",
  address =      "Washington DC, USA",
  NOURL =          "http://www.cs.bham.ac.uk/~wbl/biblio/gecco2005/docs/p1689.pdf",
  doi =          "doi:10.1145/1068009.1068292",
  publisher =    "ACM Press",
  publisher_address = "New York, NY, 10286-1405, USA",
  month =        "25-29 " # jun,
  organisation = "ACM SIGEVO (formerly ISGEC)",
  keywords =     "genetic algorithms, genetic programming, combinators,
                 experimentation, exponentiation, factorial, Fibonacci
                 sequence, iteration, languages, parity, push,
                 recursion, reversing a list, sorting, stack-based
                 genetic programming",
  abstract =     "One of Push's attractive features in this context is
                 its transparent support for the expression and
                 evolution of modular architectures and complex control
                 structures, achieved through explicit code
                 self-manipulation. The latest version of Push, Push3,
                 enhances this feature by permitting explicit
                 manipulation of an execution stack that contains the
                 expressions that are queued for execution in the
                 interpreter. presents a series of examples in which
                 Push3 was used with a simple genetic programming system
                 (PushGP) to evolve programs with non-trivial control
                 structures.",
  notes =        "GECCO-2005 A joint meeting of the fourteenth
                 international conference on genetic algorithms
                 (ICGA-2005) and the tenth annual genetic programming
                 conference (GP-2005).

                 ACM Order Number 910052

                 Cited by \cite{eurogp06:AgapitosLucas}

                 EXEC stack. Combinators. Reentrant p1691 'the
                 re-entrant interpreter allows for the controlled
                 execution of a particular number of instructions per
                 time-step.' Reversing a list. Factorial. Fibonacci.
                 Parity. Powers of two, integer exponentiation
                 Expt(2,n). Sorting a list.",
}